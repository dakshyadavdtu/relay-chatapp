# Phase 1–6 System Verification Matrix

**Repo:** Current integrated project (cookie auth / real mode).  
**Purpose:** Strict verification checklist for previously applied fixes. **NO code changes** — validation only.

---

## 1. Checklist table

| Row | Issue | Repro steps (2–5) | Expected behavior | Actual (code/logs) | Implementation (files + lines) | Logs (instrumentation removed; use normal logs) |
|-----|--------|-------------------|-------------------|--------------------|--------------------------------|----------------------|
| **A** | Presence spam / stack overflow | 1. Open chat in two tabs as same user. 2. Close one tab. 3. Watch console/network and backend logs. | Exactly one `PRESENCE_OFFLINE` per user when last socket for that user closes; no repeated floods or stack overflow. | Backend: `onDisconnect` returns early when `activeConnectionCount === 0` and presence already offline (idempotent guard). `notifyPresenceChange` sends one `PRESENCE_UPDATE` to all *other* connected users per change. | `backend/websocket/connection/lifecycle.js` 43–53 (idempotent guard: `activeConnectionCount === 0 && currentPresence === 'offline'` → return). `backend/websocket/connection/presence.js` 25–45 (`notifyPresenceChange` single broadcast). | Backend: `[TEMP onDisconnect]` (lifecycle.js:50) shows `userId`, `currentPresence`, `activeConnectionCount`. Expect `activeConnectionCount: 0` once when last tab closes; then early return on subsequent close events. |
| **B** | Cross-browser message delivery needs refresh | 1. UserA in Browser1, UserB in Browser2 (or second tab). 2. UserA sends DM to UserB. 3. Observe UserB’s view without refresh. | UserB sees the new message in the thread immediately (no refresh). | Backend delivers via `sendToUserSocket(recipientId, MESSAGE_RECEIVE)`. Frontend handles `MESSAGE_RECEIVE` in ChatAdapterContext and updates `messagesByConversation`; UI re-renders from context. If UserB’s WS is connected and backend targets that socket, message appears. | `backend/websocket/services/message.service.js` 53–88 (`sendToUserSocket`), 125–194 (`attemptDelivery`). `myfrontend/frontend/src/features/chat/adapters/ChatAdapterContext.jsx` ~446–448 (`MESSAGE_RECEIVE` → `mergeMessageReceiveRef`). | This instrumentation was removed. Use normal server logs; delivery is in `message.service.js` (sendToUserSocket, attemptDelivery). |
| **C** | Room name missing until refresh | 1. UserA creates room, adds UserB. 2. UserB (new member) opens app / has chat open. 3. UserB receives ROOM_MEMBERS_UPDATED. | UserB sees room name in sidebar immediately (no refresh). | Backend sends `name`/`thumbnailUrl` in every ROOM_MEMBERS_UPDATED. Frontend merges them into `roomsById`; if `msg.name == null`, frontend requests ROOM_INFO and merges ROOM_INFO_RESPONSE. | `backend/websocket/handlers/room.js` 48–60 (`buildRoomMembersUpdatedPayload`: `name`, `thumbnailUrl` from `snap.meta`), 93, 176, 395, 421, 450 (all broadcasts use it). `myfrontend/frontend/src/features/chat/adapters/ChatAdapterContext.jsx` 673–677 (merge meta), 689–693 (request ROOM_INFO if no name). | — |
| **D** | "Not authorized to mark this message as read" | 1. Open a room; or send a DM and mark as read from wrong context. 2. Trigger read-ack (e.g. open DM as recipient). | No toast/error "Not authorized to mark this message as read". DM read receipts still work for recipient. | Frontend sends MESSAGE_READ only for DMs (`direct:`/`dm-`), never for `room:`; only when message is from other user and (if present) `recipientId === me`. Backend rejects room messages with ROOM_READ_NOT_SUPPORTED before recipientId check. Toast suppressed for NOT_AUTHORIZED/ROOM_READ_NOT_SUPPORTED on read-ack path. | `myfrontend/frontend/src/features/chat/adapters/ChatAdapterContext.jsx` 1348–1376 (`markAsReadForConversation`: room check, sender/recipient/roomId guards), 511–513 (suppress toast). `myfrontend/frontend/src/features/chat/ui/ChatWindow.jsx` 139–149 (effect only for DM). `backend/services/message.service.js` 448–451 (room → ROOM_READ_NOT_SUPPORTED); `backend/websocket/handlers/readAck.js` 17–42 (handler; NOT_AUTHORIZED only after room check in service). | — |
| **E** | Admin online users stuck at 0 | 1. Log in as admin. 2. Open Admin Dashboard. 3. Have one or more users connected (e.g. another tab or browser). | Dashboard shows correct non-zero "Online Users" and role breakdown. | Connections aggregator counts live sockets: iterates `s.sockets` (Set) per session and uses `isSocketLive(ws)`. Snapshot uses that for `totalConnections`; GET /api/admin/dashboard maps to `onlineUsers`. | `backend/observability/aggregators/connections.js` 20–26 (`isSocketLive`), 46–66 (iterate `s.sockets`, count live only), 91–98 (fallback path). `backend/observability/snapshot.js` 66–69, 84–86. `backend/http/controllers/admin.controller.js` 199–206 (`onlineUsers: connections.totalConnections`). | — |
| **F** | Admin messages/sec wrong or stuck | 1. Log in as admin; open Dashboard. 2. Send DMs and/or room messages. 3. Watch "Messages Per Second" card. | MPS updates when messages are persisted (DM and room). | `trackPersistedMessageTimestamp()` called after every persist: message.service (DM) and room handler (room). Messages aggregator uses that window for MPS; snapshot and dashboard buffer use it. | `backend/services/message.service.js` 220, 260, 292 (DM persist). `backend/websocket/handlers/room.js` 223–226 (room persist). `backend/observability/aggregators/messages.js` 86–91, 21–44 (`getMessagesSummary`). `backend/observability/adminDashboardBuffer.js` 24–37 (`sample` → messagesAggregator.getMessagesSummary). | — |
| **G** | Admin graphs not live / admin auto-refresh | 1. Log in as admin; open Dashboard. 2. Wait 5–10 s without manual refresh. 3. Change load (e.g. connect another user or send messages). | Cards and System Performance graph update automatically every ~4 s; no full page reload. | Polling every 4 s when status is success; `refetch({ silent: true })` so no loading flash. Interval cleared on unmount. | `myfrontend/frontend/src/features/admin/adapters/useAdminDashboard.js` 27, 80–84. `useAdminDashboardTimeseries.js` 20, 72–76. `useAdminDashboardStats.js` 20, 68–72. `useAdminDashboardActivity.js` 31, 84–88. | — |
| **H** | Admin panel hard-refresh/remount on root login | 1. Log out. 2. Log in as root/admin with `?next=/admin`. 3. Observe navigation. | SPA navigation to /admin (no full page reload). | Login uses wouter `setLocation(getNextPath())`; no `window.location.reload()` or `location.assign` for normal post-login. Hard redirects only on 401/session_switched in http.js. | `myfrontend/frontend/src/pages/auth/Login.jsx` 58–60 (`setLocation(getNextPath())`). `myfrontend/frontend/src/routes.jsx` 130–137 (Route /admin with RequireAuth + RequireRole). `myfrontend/frontend/src/lib/http.js` 22–33 (handleSessionExpired → assign /login), 36–47 (handleSessionSwitched → assign /login). | — |
| **I** | Different user in 2 tabs logs out old tab on refresh | 1. Tab1: UserA logged in. 2. Tab2: UserB logs in (cookie mode). 3. Tab1: refresh or trigger /api/me (e.g. WS reconnect). | Tab1 sees session-switched and redirects to /login (expected in cookie mode: single session per origin). | Cookie mode: one session per origin. When Tab2 logs in as UserB, Tab1’s cookie is replaced; next /api/me or refresh in Tab1 gets 401 or session-switch fingerprint; handleSessionSwitched or handleSessionExpired runs and redirects to /login. | `myfrontend/frontend/src/lib/http.js` 94–107 (cookie mode + /me 401 + lastSeen !== current user → handleSessionSwitched), 22–33 (handleSessionExpired). `myfrontend/frontend/src/features/auth/SessionSwitchListener.jsx` 11–25 (subscribeSessionSwitch → clear auth, shutdown WS, `window.location.assign('/login?reason=session_switched')`). | — |

---

## 2. Bullet notes (per row)

- **A (Presence):** Idempotent guard prevents duplicate PRESENCE_OFFLINE when multiple sockets close; single broadcast per status change. If you see repeated `[TEMP onDisconnect]` with same userId and `activeConnectionCount: 0`, the early return should still prevent multiple `notifyPresenceChange` calls.
- **B (Cross-browser delivery):** If messages still “need refresh,” confirm UserB’s WS is connected (HELLO_ACK) and backend logs show `MESSAGE_RECEIVE_send` or `MESSAGE_RECEIVE_attemptDelivery` with `socketCount` > 0 for UserB. If `socketCount === 0`, recipient is offline from server’s view (different issue).
- **C (Room name):** Backend includes `name`/`thumbnailUrl` in all ROOM_MEMBERS_UPDATED; frontend merges and falls back to ROOM_INFO request when name is missing. Sidebar reads from `roomsById[roomId].name`.
- **D (Read-ack):** Frontend never sends MESSAGE_READ for rooms or own messages; backend returns ROOM_READ_NOT_SUPPORTED for room messageIds; toast suppressed for read-ack NOT_AUTHORIZED/ROOM_READ_NOT_SUPPORTED.
- **E (Admin online users):** Aggregator counts each live socket in `s.sockets`; GET /api/admin/dashboard uses snapshot → `connections.totalConnections` → `onlineUsers`.
- **F (Admin MPS):** Room handler calls `trackPersistedMessageTimestamp()` after room persist; message.service already did for DM; MPS is derived from that 60s window.
- **G (Admin live/refresh):** Four adapters (dashboard, timeseries, stats, activity) run a 4 s interval when status is success and call `refetch({ silent: true })`; cleanup on unmount.
- **H (Admin no hard refresh):** No code path does full reload on normal admin login; only 401/session_switched do `window.location.assign` to /login.
- **I (Two tabs, different user):** Cookie mode: one session per origin; Tab2 login invalidates Tab1’s session; Tab1’s next request or SessionSwitchListener triggers redirect to login. This is **expected**.

---

## 3. Status: PASSING vs FAILING

Based on the current codebase (Phases 1–6 fixes applied):

| Row | Status | Notes |
|-----|--------|------|
| A | **PASS** | Idempotent guard and single broadcast in place. Verify with two tabs, close one; expect one PRESENCE_OFFLINE and no flood. |
| B | **VERIFY** | Delivery path is implemented; if “needs refresh” still occurs, verify WS connected and backend logs for UserB's socketCount. (WS_DEBUG_MODE instrumentation was removed.) |
| C | **PASS** | ROOM_MEMBERS_UPDATED includes meta; frontend merges and requests ROOM_INFO when name missing. |
| D | **PASS** | Frontend gating + backend ROOM_READ_NOT_SUPPORTED + toast suppression. |
| E | **PASS** | Connections aggregator uses s.sockets and isSocketLive. |
| F | **PASS** | trackPersistedMessageTimestamp in room handler + message.service; MPS from messages aggregator. |
| G | **PASS** | 4 s polling with silent refetch in all four dashboard adapters; cleanup on unmount. |
| H | **PASS** | Login uses setLocation (SPA); no reload on normal admin access. |
| I | **PASS** | Cookie-mode behavior; SessionSwitchListener and http.js implement expected “other tab logs in → this tab redirects to login.” |

**Summary:** Rows **A, C, D, E, F, G, H, I** are **PASS** (implementation complete; validate manually per repro steps). Row **B** is **VERIFY** (implementation present; if issues remain, use logs to confirm recipient socket count and delivery path).
